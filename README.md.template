# Papers for Software Engineers [![workflow](https://github.com/facundoolano/software-papers/actions/workflows/tests.yml/badge.svg)](https://github.com/facundoolano/software-papers/actions/workflows/tests.yml)

A curated list of papers that may be of interest to Software Engineering students or professionals.
See the [sources](#sources) and [selection criteria](#selection-criteria) below.

<br/>

<details open>
<summary>List of papers by topic</summary>
<br/>

{{ PAPERS_FULL }}

</details>

<br/>

<details>
<summary>Top-level papers only</summary>
<br/>

{{ PAPERS_TOC }}

</details>

<br/>

<details>
<summary>All papers in chronological order </summary>
<br/>

{{ PAPERS_SORTED }}

</details>

## Sources
This list was inspired by (and draws from) several books and paper collections:

* [Papers We Love](https://paperswelove.org/)
* [Ideas That Created the Future](https://mitpress.mit.edu/books/ideas-created-future)
* [The Innovators](https://www.simonandschuster.com/books/The-Innovators/Walter-Isaacson/9781476708706)
* [The morning paper](https://blog.acolyer.org/)
* [Distributed systems for fun and profit](http://book.mixu.net/distsys/index.html)
* [Readings in Database Systems (the Red Book)](http://www.redbook.io/)
* [Fermat's Library](https://fermatslibrary.com/journal_club)
* [Classics in Human-Computer Interaction](https://medium.com/@aschugart/classics-in-hci-research-papers-critical-to-the-field-of-human-computer-interaction-1344039334a5)
* [Awesome Compilers](https://github.com/aalhour/awesome-compilers#papers)
* [Distributed Consensus Reading List](https://heidihoward.github.io/distributed-consensus-reading-list/)

## Meta reads

A few interesting resources about reading papers from Papers We Love and elsewhere:

- [Should I read papers?](https://michaelrbernste.in/2014/10/21/should-i-read-papers.html)
- [How to Read an Academic Article](https://organizationsandmarkets.com/2010/08/31/how-to-read-an-academic-article/)
- How to Read a Paper. [Keshav (2007)](http://ccr.sigcomm.org/online/files/p83-keshavA.pdf).
- Efficient Reading of Papers in Science and Technology. [Hanson (1999)](https://www.cs.columbia.edu/~hgs/netbib/efficientReading.pdf).
- On ICSE’s “Most Influential Papers”. [Parnas (1995)](http://sei.pku.edu.cn/~yaoguo/PhDReading07/parnas-review.pdf).

## Selection criteria

1. The list should stay short. Let's say no more than 30 papers.
   - The idea is not to include every interesting paper that I come across but rather to keep a representative list that's possible to read from start to finish with a similar level of effort as reading a technical book from cover to cover.
   - I tried to include one paper per each major topic and author. Since in the process I found a lot of noteworthy alternatives, related or follow-up papers and I wanted to keep track of those as well, I included them as sublist items.
2. The papers shouldn't be too long. For the same reasons as the previous item, I try to avoid papers longer than 20 or 30 pages.
3. They should be self-contained and readable enough to be approachable by the casual technical reader.
4. They should be freely available online.
5. Although historical relevance was taken into account, I omitted seminal papers in the cases where I found them hard to approach, when the main subject of the paper wasn't the thing that made them influential, etc.
   - Examples of this are classic works by Von Neumann, Turing and Shannon.
   - That being said, where possible I preferred the original paper on each subject over modern updates or survey papers.
6. I tended to prefer topics that I can relate to my professional practice, typically papers originated in the industry
or about innovations that later saw wide adoption.
   - Similarly, I tended to skip more theoretical papers, those focusing on mathematical foundations for Computer Science, electronic aspects of hardware, etc.
   - Machine Learning is mostly missing because I'm not familiar enough with the area to find relevant, non overly specific papers. Suggestions are welcome.
7. I sorted the list by a mix of relatedness of topics and a vague chronological relevance, such that it makes sense to read it in the suggested order. For example, historical and seminal topics go first, contemporary internet-era developments last, networking precedes distributed systems, etc.
   
